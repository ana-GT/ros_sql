#!/usr/bin/env python
import argparse
import StringIO
import sys, time
import Queue
import sqlalchemy

import roslib
roslib.load_manifest('ros_sql')
import rospy
import ros_sql.ros2sql as ros2sql
import ros_sql.factories as factories
import rostopic
import rosgraph.masterapi

class Recorder:
    def __init__(self,topics,bind_url,all=False):
        rospy.init_node('sql_recorder', anonymous=True)

        engine = sqlalchemy.create_engine(bind_url)
        rospy.loginfo('saving to %r'%bind_url)

        self.metadata = sqlalchemy.MetaData(bind=engine)

        self.topics = topics
        self.subscribed_topics = []
        self.record_all = all

        if self.record_all:
            assert len(self.topics)==0

        self.q = Queue.Queue()

        self.check_master()
        if self.record_all:
            rospy.Timer(rospy.Duration(1.0), self.check_master)

    def check_master(self,*args):
        new_topics = []

        master = rosgraph.masterapi.Master('/rostopic')
        try:
            state = master.getSystemState()
            pubs, subs, _ = state
            for t, l in pubs:
                if self.record_all or t in self.topics:
                    new_topics.append(t)
        except socket.error:
            raise rostopic.ROSTopicIOException(
                "Unable to communicate with master!")

        list_of_topics_and_messages = []
        topic2msg_class = {}
        for topic in new_topics:
            if topic in self.subscribed_topics:
                continue
            msg_class, _, _ = \
                       rostopic.get_topic_class(topic, blocking=True)
            topic2msg_class[topic] = msg_class
            list_of_topics_and_messages.append( (topic,msg_class) )

        ros2sql.add_schemas(self.metadata,list_of_topics_and_messages)

        for topic in topic2msg_class:
            rospy.loginfo('subscribing to topic: %r'%topic)

            msg_class = topic2msg_class[topic]
            rospy.Subscriber( topic, msg_class, callback=self.cb,
                              callback_args=topic)
            self.subscribed_topics.append( topic )

    def cb(self, msg, topic):
        now = rospy.get_rostime()
        self.q.put( (now,msg,topic) )

    def run(self):
        while not rospy.is_shutdown():
            try:
                # Block but timeout so we handle SIGINT (Ctrl-C).
                (now,msg,topic) = self.q.get(block=True,timeout=0.1)
            except Queue.Empty:
                pass
            else:
                factories.msg2sql(self.metadata,
                                  topic,
                                  msg,
                                  timestamp=now)

def record(args):
    if args.all and len(args.topic):
        print >> sys.stderr, 'Use of --all and individual topic names mutually exclusive'
        sys.exit(1)
    if not len(args.topic) and not args.all:
        print >> sys.stderr, 'Neither --all nor individual topic name(s) given. Nothing to do.'
        sys.exit(1)
    r = Recorder(args.topic,args.bind,all=args.all)
    r.run()

def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title='commands')

    # ------ record --------------
    parser_record = subparsers.add_parser('record',
                                          help='record ros topics to SQL')
    parser_record.add_argument('-a','--all',action='store_true',default=False,
                               help='record all topics')
    parser_record.add_argument('-b','--bind',type=str,
                               default='sqlite:///ros.sqlite3',
                               help='sqlalchemy URL for database connection')
    parser_record.add_argument('topic', nargs='*',
                               help='topic name(s) to be recorded')
    parser_record.set_defaults(func=record)
    # ----------------------------

    # use argparse, but only after ROS did its thing
    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    args.func(args)

if __name__=='__main__':
    main()
