#!/usr/bin/env python
import argparse
import StringIO
import sys, time
import Queue

import elixir

import roslib
roslib.load_manifest('ros_sql')
import rospy
import ros_sql.ros2sql as ros2sql
import rostopic
import rosgraph.masterapi

class Recorder:
    def __init__(self,topics,bind_url,all=False):
        rospy.init_node('sql_recorder', anonymous=True)

        if all:
            assert len(topics)==0
            master = rosgraph.masterapi.Master('/rostopic')
            try:
                state = master.getSystemState()
                pubs, subs, _ = state
                for t, l in pubs:
                    topics.append(t)
            except socket.error:
                raise rostopic.ROSTopicIOException(
                    "Unable to communicate with master!")

        texts = []
        class_names = []
        table_names = []
        topic2schema_name = {}
        list_of_topics_and_messages = []
        for topic in topics:
            msg_class, _, _ = \
                       rostopic.get_topic_class(topic, blocking=True)
            #print 'topic: %r, msg_class: %r'%(topic,msg_class)
            list_of_topics_and_messages.append( (topic,msg_class) )

        schema_results = ros2sql.build_schemas(list_of_topics_and_messages)
        if 1:
            with open('schema.py',mode='w') as fd:
                fd.write(schema_results['schema_text'])

        USE_EXEC=False
        if USE_EXEC:
            schema_ns = {}
            exec schema_results['schema_text'] in schema_ns
            schema = Bunch(**schema_ns) # make it act like a module
            del schema_ns
        else:
            import schema
            self.schema = schema

            import ros_sql.factories as factories
            self.factories = factories

        # start elixer operations on schema
        elixir.metadata.bind = bind_url
        #elixir.metadata.bind.echo = True
        elixir.setup_all()
        elixir.create_all()

        self.q = Queue.Queue()
        for topic in topics:
            msg_class, _, _ = \
                       rostopic.get_topic_class(topic, blocking=True)
            rospy.Subscriber( topic, msg_class, callback=self.cb,
                              callback_args=topic)

    def cb(self, msg, topic):
        now = rospy.get_rostime()
        self.q.put( (now,msg,topic) )

    def run(self):
        while not rospy.is_shutdown():
            (now,msg,topic) = self.q.get()

            self.factories.msg2sql(topic,
                                   msg,
                                   timestamp=now,
                                   session=elixir.session)
            #elixir.session.commit()

def record(args):
    if args.all and len(args.topic):
        print >> sys.stderr, 'Use of --all and individual topic names mutually exclusive'
        sys.exit(1)
    if not len(args.topic) and not args.all:
        print >> sys.stderr, 'Neither --all nor individual topic name(s) given. Nothing to do.'
        sys.exit(1)
    r = Recorder(args.topic,args.bind,all=args.all)
    r.run()

def main():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title='commands')

    # ------ record --------------
    parser_record = subparsers.add_parser('record',
                                          help='record ros topics to SQL')
    parser_record.add_argument('-a','--all',action='store_true',default=False,
                               help='record all topics')
    parser_record.add_argument('-b','--bind',type=str,
                               default='sqlite:///ros.sqlite3',
                               help='sqlalchemy URL for database connection')
    parser_record.add_argument('topic', nargs='*',
                               help='topic name(s) to be recorded')
    parser_record.set_defaults(func=record)
    # ----------------------------

    # use argparse, but only after ROS did its thing
    argv = rospy.myargv()
    args = parser.parse_args(argv[1:])

    args.func(args)

if __name__=='__main__':
    main()
